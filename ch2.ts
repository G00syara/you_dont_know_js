// Свойства объектов

var obj = {
	a: "hello world",
	b: 42
};

var c = "a";

obj[c];			// "hello world"
obj["b"];		// 42

console.log(
obj[c],
obj["b"])


// ----------------------------------------------------------------------
// Особый список "как бы ложных" значений в JavaScript таков:

// "" (пустая строка)
// 0, -0, NaN (некорректное число)
// null, undefined
// false
// Любое значение, не входящее в этот список — "как бы истинно." Вот несколько примеров:

// "hello"
// 42
// true
// [ ], [ 1, "2", 3 ] (массивы)
// { }, { a: 42 } (объекты)
// function foo() { .. } (функции)

// ----------------------------------------------------------------------
function foo() {
	a = 1;	// `a` формально не объявлена
}

foo();
console.log(a);			// 1 — упс, автоматическая глобальная переменная :(

// ----------------------------------------------------------------------
	function foo() {
		"use strict";
	
		// этот код в строгом режиме
	
		function bar() {
			// этот код в строгом режиме
		}
	}
	
	// этот код в нестрогом режиме

// ----------------------------------------------------------------------

	"use strict";

function foo() {
	// этот код в строгом режиме

	function bar() {
		// этот код в строгом режиме
	}
}

// этот код в строгом режиме

// ----------------------------------------------------------------------
//Анонимная функция
var foo = function() {
	// ..
};

//Именованная функция
var x = function bar(){
	// ..
};
// ----------------------------------------------------------------------
function foo() { .. }

// `foo` выражение со ссылкой на функцию,
// затем `()` выполняют ее
foo();

// Выражение с функцией `IIFE`,
// затем `()` выполняют ее
(function IIFE(){ .. })();

// ----------------------------------------------------------------------

function makeAdder(x) {
	// параметр `x` - внутренняя переменная

	// внутренняя функция `add()` использует `x`, поэтому
	// у нее есть "замыкание" на нее
	function add(y) {
		return y + x;
	};

	return add;
}

// `plusOne` получает ссылку на внутреннюю функцию `add(..)`
// с замыканием на параметре `x`
// внешней `makeAdder(..)`
var plusOne = makeAdder( 1 );

// `plusTen` получает ссылку на внутреннюю функцию `add(..)`
// с замыканием на параметре `x`
// внешней `makeAdder(..)`
var plusTen = makeAdder( 10 );

plusOne( 3 );		// 4  <-- 1 + 3
plusOne( 41 );		// 42 <-- 1 + 41

plusTen( 13 );		// 23 <-- 10 + 13


// ----------------------------------------------------------------------


function foo() {
	console.log( this.bar );
}

var bar = "global";

var obj1 = {
	bar: "obj1",
	foo: foo
};

var obj2 = {
	bar: "obj2"
};

//--------

foo();				// "global"
obj1.foo();			// "obj1"
foo.call( obj2 );	// "obj2"
new foo();			// undefined

// Есть четыре правила того, как устанавливается this, и они показаны в этих четырех последних строках кода.

// foo() присваивает в this ссылку на глобальный объект в нестрогом режиме. В строгом режиме, 
// this будет undefined, и вы получите ошибку при доступе к свойству bar, поэтому "global" — это значение для this.bar.
// obj1.foo() устанавливает this в объект obj1.
// foo.call(obj2) устанавливает this в объект obj2.
// new foo() устанавливает this в абсолютно новый пустой объект.

// ----------------------------------------------------------------------

function foo(a) {

	var b = a * 2;

	function bar(c) {
		console.log( a, b, c );
	}

	bar(b * 3);
}

foo( 2 ); // 2 4 12

// ----------------------------------------------------------------------

// Поиск в области видимости прекращается как только он находит первое совпадение.

// --------------------Обманываем лексическую область видимости-----------------------
//------------------------eval-------------
function foo(str, a) {
	eval( str ); // обман!
	console.log( a, b );
}

var b = 2;

foo( "var b = 3;", 1 ); // 1, 3

// При строгом режиме это не сработает
function foo(str) {
	"use strict";
	eval( str );
	console.log( a ); // ReferenceError: a is not defined
 }
 
 foo( "var a = 2" );

 //-------------------------with---------------

 function foo(obj) {
	with (obj) {
		a = 2;
	}
}

var o1 = {
	a: 3
};

var o2 = {
	b: 3
};

foo( o1 );
console.log( o1.a ); // 2

foo( o2 );
console.log( o2.a ); // undefined
console.log( a ); // 2 — Упс, утекшая глобальная переменная!

// Оператор with берет объект, у которого есть ноль или более свойств, и трактует этот объект 
// как если бы он являлся целиком отдельной лексической областью видимости, 
// и таким образом свойства объекта воспринимаются как лексически определенные идентификаторы в этой "области видимости".