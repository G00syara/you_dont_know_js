var obj = {
	a: "hello world",
	b: 42
};

var c = "a";

obj[c];		
obj["b"];	//Строчечная нотация, полезна для обработки строки или чего то подобного

// ------------------------


function foo() {
	return 42;
}

foo.bar = "hello world";
console.log(typeof foo.bar);		// "string"
foo.bar = Symbol("hello world"); // symbol
foo.bar = Array("hello world"); //object
foo.bar = Object("hello world"); //object

//Вывод типа
console.log(typeof foo);			// "function"
console.log(typeof foo());		// "number"
console.log(typeof foo.bar);	

// ------------------------

/*
a == b 
Затратит больше ресурсов и будет более нагруженным, чем a === b
Т.к. будет тратиться ресурсы на приведение типов
*/

// ------------------------

var a = [1,2,3];
var b = [1,2,3];
var c = "1,2,3";

a == c;		// true, Typesript жалуется, JS разрешил бы
b == c;		// true, Typesript жалуется, JS разрешил бы
a == b;		// false


// ----------------------------------------------------------------
var a = 42;
var b = "foo";

a < b;		// false
a > b;		// false
a == b;		// false
// Т.к. у нас сравнивается число и строка, то строка пытается привестись к числовому значению, но по итогу приводиться к NaN
// А NaN не больше и не меньше, чем любое другое значение.
// 42 == NaN, тоже не равно, поэтому false

// ----------------------------------------------------------------

function foo() { .. }

// `foo` выражение со ссылкой на функцию,
// затем `()` выполняют ее
foo();

// Выражение с функцией `IIFE`,
// затем `()` выполняют ее 
(function IIFE(){ .. })();
//Одинаковы в выполнении
//Выполняется с помощью () сразу после них.

// ----------------------------------------------------------------
// Функции IIFE также могут возвращать значения:

var x = (function IIFE(){
	return 42;
})();

x;	// 42
