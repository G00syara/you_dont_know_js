function foo() {
	var a = 2;

	function bar() {
		console.log( a );
	}

	return bar;
}

var baz = foo();

baz(); // 2 -- Ого, замыкание только что было раскрыто, мужики!

// bar() все еще содержит ссылку на эту область видимости и эта ссылка называется замыканием.


// Такие передачи функций могут быть также и непрямыми.

var fn;

function foo() {
	var a = 2;

	function baz() {
		console.log( a );
	}

	fn = baz; // присваиваем `baz` глобальной переменной
}

function bar() {
	fn(); // смотри мам, я видел замыкание!
}

foo();

bar(); // 2

//--------------------------------------------------------------------------------------------------------

// Спустя время все они ссылаются на 1 переменную `i`, а т.к. она изменится раньше, чем отработает setTimeout, то выведет всегда i

for (var i=1; i<=5; i++) {
	setTimeout( function timer(){
		console.log( i );
	}, i*1000 );
}

// Так отработает как надо, т.к. внутри IIFE функции будет своя переменная, которая будет запомниать значение с каждым новым циклом

for (var i=1; i<=5; i++) {
	(function(){
		var j = i;
		setTimeout( function timer(){
			console.log( j );
		}, j*1000 );
	})();
}

// Здесь же отработает нормально, т.к. всплытие не произойдет, из-за let, и каждый i, будет находится в своей области видимости

for (let i=1; i<=5; i++) {
	setTimeout( function timer(){
		console.log( i );
	}, i*1000 );
}